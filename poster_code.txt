# notes for to recreate poster. 


# table of results
```

customGreen0 = "#d5efe0"
customGreen = "#71CA97"

low_nan_cov = "#fdead8"
high_nan_cov = "#f5a556"
high_ill_cov = "#2684ff"
low_ill_cov = "#c3ddff"

library(formattable)
d <- read.table("table.txt", sep = "\t", header= TRUE)
colnames(d) <- c("Length (Mb)", "%GC", "%C", "%R", "Illumina \ncoverage", "Nanopore \n coverage", "rRNA genes", "tRNA genes", "Predicted \n taxonomy")

f <- formattable(d, align = c("l", "c", "c", "c", "c", "c", "c", "c", "l"), 
        list(`Length (Mb)` = formatter("span", style = ~ style(color = "grey",font.weight = "bold")), 
        `%C`= color_tile(customGreen0, customGreen),
        `%R`= color_tile(customGreen, customGreen0),
        `Illumina \ncoverage` = color_tile(low_ill_cov, high_ill_cov),
        `Nanopore \n coverage` = color_tile(low_nan_cov, high_nan_cov), 
        `Length` = color_bar("#e7e7e7")
         )
)

# to save the file, you just have to take a screen shot of it super big on your screen. 

# making the circos plots: 

````
library(circlize)

# relative path and genome is loaded into this variable 
genome <- "contig_24"

# read in the input files
gc_info <- read.table(paste0(genome, "-gc-info.txt"), header=TRUE)
ill_cov <- read.table(paste0(genome, "-illumina-soft.regions.bed"))
ill_cov_filt <- read.table(paste0(genome, "-illumina-hard.regions.bed"))
nano_cov <- read.table(paste0(genome, "-nanopore-unfiltered.regions.bed"))
nano_cov_filt <- read.table(paste0(genome, "-nanopore-filtered.regions.bed"))

# read in coding sequence bed files
cds_pos <- read.table(paste0(genome, "-cds-positive.bed"), header=TRUE)
cds_neg <- read.table(paste0(genome, "-cds-negative.bed"), header=TRUE)
trna <- read.table(paste0(genome, "-cds-trna.bed"), header=TRUE)
rrna <- read.table(paste0(genome, "-cds-rrna.bed"), header=TRUE)
cytoband.df <- read.table(paste0(genome, "-cytoband.txt"), colClasses=c("character", "numeric", "numeric", "character", "character"))

trna$chr <- "contig_24"
cds_pos$chr <- "contig_24"
cds_neg$chr <- "contig_24"
rrna$chr <- "contig_24"

# one of cds_neg overlaps origin, just delete 
cds_neg <- cds_neg[c(1:984, 986:1529),]

# generate master bed dataframe for coverage plotting
final_bed <- ill_cov
colnames(final_bed) <- c("chr", "start", "end", "illumina_coverage")

# add coverage information to data frame
final_bed$illumina_coverage_filtered <- ill_cov_filt$V4
final_bed$nanopore_coverage <- nano_cov$V4
final_bed$nanopore_coverage_filtered <- nano_cov_filt$V4

# add gc info columns
final_bed$gc_content <- gc_info$gc_content
final_bed$gc_skew <- gc_info$gc_skew
final_bed$gc_culm <- gc_info$gc_culm

# calculate maximum nanopore coverage to display.
maximum_nanopore <- mean(final_bed$nanopore_coverage_filtered) * 1.75
maximum_illumina <- mean(final_bed$illumina_coverage) * 1.75

# replace each one that is over limit each one with maximum
final_bed$nanopore_coverage[which(final_bed$nanopore_coverage > maximum_nanopore)] <- maximum_nanopore

# adjust maximum for purpose of plotting.
final_bed$illumina_coverage[which(final_bed$illumina_coverage > maximum_illumina)] <- maximum_illumina
final_bed$illumina_coverage_filtered[which(final_bed$illumina_coverage_filtered > maximum_illumina)] <- maximum_illumina

# clear plotting region if circos plot already active.
circos.clear()

# open PDF device. this will output the file in the data folder - modify as you wish. 
pdf(paste0(genome, "-circos.pdf"), width = 12, height=15)

# rotate so the beginning of the genome is at the top
# make space between start and end for labels
# remove as much space as possible between layers.
circos.par(start.degree=75, gap.after = 30, cell.padding=c(0,0,0,0))

# this is what the cytoband.df input needs to look like. V4 and V5 are required only when you are plotting multiple chromosomes (like human data for example)
#> cytoband.df
#          V1 V2      V3       V4       V5
#1 contig_125  0 3836404 not_real not_real

# initialize using the cytoband dataframe but don't plot the default.
circos.initializeWithIdeogram(cytoband.df, plotType=NULL)

# generate track for genome.
#circos.track(ylim = c(0,1), panel.fun = function(x,y) {
#}, track.height = 0.05, bg.col="#5e6cff")

# plot all coverage tracks
circos.genomicTrackPlotRegion(final_bed, numeric.column=c("illumina_coverage", "illumina_coverage_filtered", "nanopore_coverage", "nanopore_coverage_filtered") , ylim = c(-(maximum_nanopore), maximum_illumina), panel.fun = function(region, value, ...) {

  circos.genomicLines(region, value, numeric.column="illumina_coverage", baseline = 0, col = rgb(0,0,0,0.5), border = NA, area=TRUE, ...)

  circos.genomicLines(region, value, numeric.column="illumina_coverage_filtered", baseline = 0, col = "#548ce5", border = NA, area=TRUE, ...)
  

  circos.genomicLines(region, -value, numeric.column="nanopore_coverage", baseline = 0, col = "#fdead8", border = NA, area=TRUE, ...)

  circos.genomicLines(region, -value, numeric.column="nanopore_coverage_filtered", baseline = 0, col = "#f5a556", border = NA, area=TRUE, ...)

  }, track.height = 0.2, bg.border=NA)

# add maximum coverage values for nanopore and illumina reads for scale.
circos.text(0, (maximum_illumina/1.5), adj=c(1.2, 0), labels = as.integer(maximum_illumina), cex = 0.7, col = "#FFFFFF")
circos.text(0, 0, labels = "0", cex = 0.7, adj=c(1.2, 0), col = "#FFFFFF")
circos.text(0, -maximum_nanopore, labels = as.integer(maximum_nanopore), adj=c(1.2, 0), cex = 0.7, col = "#FFFFFF")
 

# plot gc_content track
circos.genomicTrackPlotRegion(final_bed, numeric.column="gc_content" , ylim = c(min(final_bed$gc_content),max(final_bed$gc_content)), panel.fun = function(region, value, ...) {

    circos.genomicLines(region, value, numeric.column="gc_content", baseline = 0, col = "#FFFFFF", border = NA, ...)

    }, track.height = 0.05)

# gc skew and culm track
# the gc_skew and gc_culm columns need to converted to a proportion (i.e. between 0.0 to 1.0) to be plotted on the same track.

# convert to proportion for plotting purposes. 
final_bed$gc_skew <- final_bed$gc_skew / max(final_bed$gc_skew)
final_bed$gc_culm <- final_bed$gc_culm / max(abs(final_bed$gc_culm))

# plot GC skew and culmulative skew on the same track.
circos.genomicTrackPlotRegion(final_bed, numeric.column="gc_culm", ylim = c(-1, 1), panel.fun = function(region, value, ...) {

  circos.genomicLines(region, value, numeric.column="gc_culm", baseline = 0, col = "#8f8f8f", border = NA, area=TRUE,...)

  circos.genomicLines(region, value, numeric.column="gc_skew", baseline = 0, col = "#FFFFFF", border = NA,...)

}, bg.border = NA, track.height = 0.05)

# plot positive coding sequence track
circos.genomicTrackPlotRegion(cds_pos, numeric.column="cds_pos", ylim = c(0, 1), panel.fun = function(region, value, ...) {

  # in every region, print a vertical line at the start region.
  for (k in seq_len(nrow(region))){
    # plot vertical lines for each START of the ORF from bottom to top.
      circos.lines(rep(region[k, 1], 2), c(0, 1), lwd = 0.5, straight = TRUE, col = "#FFFFFF")
  }

}, bg.border = NA, track.height = 0.05)

# plot negative coding sequence track
circos.genomicTrackPlotRegion(cds_neg, numeric.column="cds_neg", ylim = c(0, 1), panel.fun = function(region, value, ...) {

  # in every region, print a vertical line at the start region.
  for (k in seq_len(nrow(region))){
    # plot vertical lines for each START of the orf from bottom to top.
      circos.lines(rep(region[k, 1], 2), c(0, 1), lwd = 0.5, straight = TRUE, col = "#FFFFFF")
  }

}, bg.border = NA, track.height = 0.05)

# plot tRNA and rRNA track
circos.genomicTrackPlotRegion(list(trna, rrna), ylim = c(0, 1), panel.fun = function(region, value, ...) {

  # this will iterate through the list of bed dataframes (trna and rrna)
  i = getI(...)

  # plot tRNAs
  if (i == 1){

    for (k in seq_len(nrow(region))){
      # plot vertical lines for each START of the orf from bottom to top.
        circos.lines(rep(region[k, 1], 2), c(0, 1), lwd = 2, straight = TRUE, col = "#FFFFFF")
    }

  } else {
    # plot rRNAs as red
    for (k in seq_len(nrow(region))){
      # plot vertical lines for each START of the orf from bottom to top.
        circos.lines(rep(region[k, 1], 2), c(0, 1), lwd = 2, straight = TRUE, col = "#dd9521")
    }
  }
}, bg.border = NA, track.height = 0.05)

# clear the plotting area
circos.clear()

# plot the labels in the middle
text(0, 0.88, "Illumina coverage", cex = 1.2, col = "#FFFFFF")
text(0, 0.82, "Nanopore coverage", cex = 1.2, col = "#FFFFFF")
text(0, 0.75, "GC content", cex = 1.3, col = "#FFFFFF")
text(0, 0.68, "GC skew", cex = 1.3, col = "#FFFFFF")
text(0, 0.6, "CDS (+)", cex = 1.3, col = "#FFFFFF")
text(0, 0.52, "CDS (-)", cex = 1.3, col = "#FFFFFF")
text(0, 0.43, "tRNA (White)\n rRNA (Orange)", cex = 1.3, col = "#FFFFFF")
text(0, 0, "Parvibaculum", cex = 3.5, col = "#FFFFFF")
text(0, -0.1, paste0("Genome size: ", cytoband.df$V3), cex = 1.3, col = "#FFFFFF")

dev.off()
```

# Now to remake the coverage plots with the correct colours and better dimensions. 

```
# munging

### gc content and coverage 
# cd /Volumes/seagate/abahcheli-seagate/mag-validation-seagate/full-attempt/output/circos
d <- read.table("contig_24-gc-info.txt", header=TRUE)
ill_cov <- read.table("contig_24-illumina-hard.regions.bed")
nan_cov <- read.table("contig_24-nanopore-filtered.regions.bed")

# get relatively large window
range <- c(2966:3090)

# subset all variables so the x axis remains consistent.
d.sub <- d[range,]
ill.sub <- ill_cov[range,]
nan.sub <- nan_cov[range,]

### overlapping reads 

# need to map subsetted reads to final assembly for PAF output
# cd /Volumes/seagate/abahcheli-seagate/mag-validation-seagate/full-attempt/contig_690
# MAP='/Volumes/data/bin/minimap2/minimap2'
# $MAP -x map-ont -t 10 contig_690-final-assembly-oriented.fasta nanopore-filtered-to-final.fastq > pseudoisolate-nanopore-to-final-oriented.paf

# this is the output from minimap 
paf <- read.table("reads_to_oriented_assembly.paf", stringsAsFactors=FALSE, fill=TRUE)

# need to find a range of reads. for initial filtering the start OR end position needs to within 3023000 and 3031000

# starting position or ending position in the region
paf.sub <- paf[which( (paf$V8 > 2933000 & paf$V8 < 3023000) | (paf$V9 > 3031000 & paf$V9 < 3121000)),]

# filter the output so that the query coverage is > 90%
paf.sub.filt <- paf.sub[which( ( (paf.sub$V4 - paf.sub$V3) / paf.sub$V2) > 0.9),]

# filter so the minimum read length is > 1000
paf.sub.filt.2 <- paf.sub.filt[which(paf.sub.filt$V2 > 10000 ),]


# further filter so that all remaining reads pass over a junction at 250000 or 284000. 

# range the start to length, check to see if 254000 or 281000 is in that range. 

# initiate final dataframe. 1st row will be replaced, others will be added on
paf.final <- paf.sub.filt.2[1,]

# initialize counter
counter <- 1

for (i in 1:dim(paf.sub.filt.2)[1]) {
    
    if (3027000 %in% paf.sub.filt.2$V8[i]:paf.sub.filt.2$V9[i] && 3025000 %in% paf.sub.filt.2$V8[i]:paf.sub.filt.2$V9[i]  ) {
        paf.final[counter,] <- paf.sub.filt.2[i,]
        # add to counter. this is needed to add a row at the appropriate spot in the final dataframe
        counter <- counter + 1
    }

}



# take only reads that > 15 kb
#paf.final.sub.unfiltered <- paf.final[which(paf.final$V2 > 15000),]
paf.final.sub.unfiltered <- paf.final


# get rid of a few that don't really show anything
#paf.final.sub <- paf.final.sub.unfiltered[sample(1:32, 25, replace = FALSE),]
# get rid of a few that don't really show anything
paf.final.sub <- paf.final.sub.unfiltered

################################################################################

# overlapping reads 

# have three plots 
# middle: gc content
# bottom: illumina + nanopore coverage
# top: overlapping reads 
# it would be cool to 
# mai: bottom left top right
pdf("contig_24-overlap.pdf", width = 8, height = 5)
par(mfrow=c(2,1), mai = c(0.1, 0.82, 0.1, 0.42))

plot(y = d.sub$gc_content, x = ill.sub$V2, ylim = c(0, 17), ylab = "Overlapping reads", xlab = "", type = "n", axes=FALSE, xlim = c(ill.sub$V2[5], ill.sub$V2[(length(ill.sub$V2) - 5)]))

# x0, y0, x1, y1

for (i in 1:dim(paf.final.sub)[1]) {
    
    # if positive strand
    
    if  (paf.final$V5[i] == "+") {
        # increment arrows by 1 every iteration
        arrows(x0=paf.final.sub$V8[i], y0=i, x1=paf.final.sub$V9[i], y1=i, lwd = 2, angle = 20, length = 0.1, col = rgb(245, 185, 96, 255, max = 255))
    } else { 
        # negative strand, plot backwards
        arrows(x0=paf.final.sub$V9[i], y0=i, x1=paf.final.sub$V8[i], y1=i, lwd = 2, angle = 20, length = 0.1, col = rgb(245, 140, 76, 255, max = 255))
    }
    
}

axis(2, c(0, 17)) 

abline(v= 3026000, lty = 2, col = rgb(0,0,0,0.7))

    
################################################################################

# coverage

# change the mai options for par to see the axis. 
par(mai = c(0.6, 0.82, 0.1, 0.42))

# change the first and last point to zero so the polygon shades to the x-axis
poly.range <- (min(range) - 2) : (max(range) + 2)

ill.poly <- ill_cov[poly.range,]
ill.poly$V4[c(1, length(ill.poly$V4))] <- 0

nan.poly <- nan_cov[poly.range,]
nan.poly$V4[c(1, length(nan.poly$V4))] <- 0

# cut off the graph early on x-axis for visual purposes. this hides the fact that polygon acts weirdly. 
# illumina coverage
plot(x = ill.sub$V2, y = ill.sub$V4, type = "l", ylab = "Coverage", xlab = "Chromosome position", ylim = c(0, max(ill.sub$V4)), xlim = c(ill.sub$V2[5], ill.sub$V2[(length(ill.sub$V2) - 5)]), axes = FALSE)

# fill in the illumina colour first
polygon(ill.poly$V2, ill.poly$V4, col = rgb(156, 199, 255, 255, max = 255), ylim = c(0, max(ill.sub$V4)), border = "blue")

# nanopore coverage
lines(x = nan.sub$V2, y = nan.sub$V4, type = "l", ylab = "", xlab = "", ylim = c(0, max(ill.sub$V4)), xlim = c(ill.sub$V2[3], ill.sub$V2[(length(ill.sub$V2) - 2)]))

# colour nanopore coverage
polygon(nan.poly$V2, nan.poly$V4,col = "#f5a556", ylim = c(0, max(ill.sub$V4)), border = "#dc740d" )


axis(1, at = c(2965000, 3026000, 3088000), labels = c("2.97 mb", "3.03 mb", "3.09 mb"), pos = 0)
axis(2, c(0, 200, 400))

abline(v= 3026000, lty = 2, col = rgb(0,0,0,0.7))
dev.off()
```

Now recreate the plot, but for the version with the insertion. 

```
# munging

### gc content and coverage 
# cd /Volumes/seagate/abahcheli-seagate/mag-validation-seagate/full-attempt/output/circos
d <- read.table("contig_24-gc-info.txt", header=TRUE)
ill_cov <- read.table("contig_24-illumina-hard.regions.bed")
nan_cov <- read.table("contig_24-nanopore-filtered.regions.bed")

# get relatively large window
range <- c(2966:3090)

# subset all variables so the x axis remains consistent.
d.sub <- d[range,]
ill.sub <- ill_cov[range,]
nan.sub <- nan_cov[range,]

### overlapping reads 

# need to map subsetted reads to final assembly for PAF output
# cd /Volumes/seagate/abahcheli-seagate/mag-validation-seagate/full-attempt/contig_690
# MAP='/Volumes/data/bin/minimap2/minimap2'
# $MAP -x map-ont -t 10 contig_690-final-assembly-oriented.fasta nanopore-filtered-to-final.fastq > pseudoisolate-nanopore-to-final-oriented.paf

# this is the output from minimap 
paf <- read.table("reads_to_oriented_assembly.paf", stringsAsFactors=FALSE, fill=TRUE)

# need to find a range of reads. for initial filtering the start OR end position needs to within 3023000 and 3031000

# starting position or ending position in the region
paf.sub <- paf[which( (paf$V8 > 2933000 & paf$V8 < 3023000) | (paf$V9 > 3031000 & paf$V9 < 3121000)),]

# filter the output so that the query coverage is > 90%
paf.sub.filt <- paf.sub[which( ( (paf.sub$V4 - paf.sub$V3) / paf.sub$V2) > 0.9),]

# filter so the minimum read length is > 1000
paf.sub.filt.2 <- paf.sub.filt[which(paf.sub.filt$V2 > 10000 ),]


# further filter so that all remaining reads pass over a junction at 250000 or 284000. 

# range the start to length, check to see if 254000 or 281000 is in that range. 

# initiate final dataframe. 1st row will be replaced, others will be added on
paf.final <- paf.sub.filt.2[1,]

# initialize counter
counter <- 1


# this is for multiple junctions
for (i in 1:dim(paf.sub.filt.2)[1]) {
    
    if (3027000 %in% paf.sub.filt.2$V8[i]:paf.sub.filt.2$V9[i] | (3062000 %in% paf.sub.filt.2$V8[i]:paf.sub.filt.2$V9[i]) ) {
        paf.final[counter,] <- paf.sub.filt.2[i,]
        # add to counter. this is needed to add a row at the appropriate spot in the final dataframe
        counter <- counter + 1
    }

}

# take only reads that > 15 kb
paf.final.sub.unfiltered <- paf.final[which(paf.final$V2 > 40000),]
#paf.final.sub.unfiltered <- paf.final

# the ones that span both junctions are: 


# randomly subset to 25. 
#paf.final.sub <- paf.final.sub.unfiltered[sample(1:159, 25, replace = FALSE),]
# get rid of a few that don't really show anything
# manual pruning of final subset. 
paf.final.sub <- paf.final.sub.unfiltered[-c(36, 4, 5, 13, 14, 16, 20, 21, 24, 28 , 30),] 


################################################################################

# overlapping reads 

# have three plots 
# middle: gc content
# bottom: illumina + nanopore coverage
# top: overlapping reads 
# it would be cool to 
# mai: bottom left top right
pdf("contig_24-insertion-overlap.pdf", width = 8, height = 5)
par(mfrow=c(2,1), mai = c(0.1, 0.82, 0.1, 0.42))

plot(y = d.sub$gc_content, x = ill.sub$V2, ylim = c(0, 25), ylab = "Overlapping reads", xlab = "", type = "n", axes=FALSE, xlim = c(ill.sub$V2[5], ill.sub$V2[(length(ill.sub$V2) - 5)]))

# x0, y0, x1, y1

for (i in 1:dim(paf.final.sub)[1]) {
    
    # if positive strand
    if  (i %in% c(1, 6, 13, 22, 23, 24)) {

        # these are all on the negative strand
        arrows(x0=paf.final.sub$V8[i], y0=i, x1=paf.final.sub$V9[i], y1=i, lwd = 2, angle = 20, length = 0.1, col = rgb(0,0,0,1))

    } else if  (paf.final.sub$V5[i] == "+") {
        # increment arrows by 1 every iteration
        arrows(x0=paf.final.sub$V8[i], y0=i, x1=paf.final.sub$V9[i], y1=i, lwd = 2, angle = 20, length = 0.1, col = rgb(245, 185, 96, 255, max = 255))
    } else { 
        # negative strand, plot backwards
        arrows(x0=paf.final.sub$V9[i], y0=i, x1=paf.final.sub$V8[i], y1=i, lwd = 2, angle = 20, length = 0.1, col = rgb(245, 140, 76, 255, max = 255))
    }
    
}

axis(2, c(0, 25)) 

abline(v= 3026000, lty = 2, col = rgb(0,0,0,0.7))
abline(v= 3061000, lty = 2, col = rgb(0,0,0,0.7))

################################################################################

# coverage

# change the mai options for par to see the axis. 
par(mai = c(0.8, 0.82, 0.1, 0.42))

# change the first and last point to zero so the polygon shades to the x-axis
poly.range <- (min(range) - 2) : (max(range) + 2)

ill.poly <- ill_cov[poly.range,]
ill.poly$V4[c(1, length(ill.poly$V4))] <- 0

nan.poly <- nan_cov[poly.range,]
nan.poly$V4[c(1, length(nan.poly$V4))] <- 0

# cut off the graph early on x-axis for visual purposes. this hides the fact that polygon acts weirdly. 
# illumina coverage
plot(x = ill.sub$V2, y = ill.sub$V4, type = "l", ylab = "Coverage", xlab = "Chromosome position", ylim = c(0, max(ill.sub$V4)), xlim = c(ill.sub$V2[5], ill.sub$V2[(length(ill.sub$V2) - 5)]), axes = FALSE)

# fill in the illumina colour first
polygon(ill.poly$V2, ill.poly$V4, col = rgb(156, 199, 255, 255, max = 255), ylim = c(0, max(ill.sub$V4)), border = "blue")

# nanopore coverage
lines(x = nan.sub$V2, y = nan.sub$V4, type = "l", ylab = "", xlab = "", ylim = c(0, max(ill.sub$V4)), xlim = c(ill.sub$V2[3], ill.sub$V2[(length(ill.sub$V2) - 2)]))

# colour nanopore coverage
polygon(nan.poly$V2, nan.poly$V4,col = "#f5a556", ylim = c(0, max(ill.sub$V4)), border = "#dc740d")

axis(1, at = c(2965000, 3026000, 3088000), labels = c("2.97 mb", "3.03 mb", "3.09 mb"), pos = 0)
axis(2, c(0, 200, 400))

abline(v= 3026000, lty = 2, col = rgb(0,0,0,0.7))
abline(v= 3061000, lty = 2, col = rgb(0,0,0,0.7))

dev.off()
```

# CPR genome. 


```

````
setwd("~data/CPR")
library(circlize)

# relative path and genome is loaded into this variable 
genome <- "contig_690"

# read in the input files
gc_info <- read.table(paste0(genome, "-gc-info.txt"), header=TRUE)
ill_cov <- read.table(paste0(genome, "-illumina-soft.regions.bed"))
ill_cov_filt <- read.table(paste0(genome, "-illumina-hard.regions.bed"))
nano_cov <- read.table(paste0(genome, "-nanopore-unfiltered.regions.bed"))
nano_cov_filt <- read.table(paste0(genome, "-nanopore-filtered.regions.bed"))

# read in coding sequence bed files
cds_pos <- read.table(paste0(genome, "-cds-positive.bed"), header=TRUE)
cds_neg <- read.table(paste0(genome, "-cds-negative.bed"), header=TRUE)
trna <- read.table(paste0(genome, "-cds-trna.bed"), header=TRUE)
rrna <- read.table(paste0(genome, "-cds-rrna.bed"), header=TRUE)
cytoband.df <- read.table(paste0(genome, "-cytoband.txt"), colClasses=c("character", "numeric", "numeric", "character", "character"))

# there are three ORFs on neg strand that overlap with origin, remove them

cds_neg <- cds_neg[4:355,]

# generate master bed dataframe for coverage plotting
final_bed <- ill_cov
colnames(final_bed) <- c("chr", "start", "end", "illumina_coverage")

# add coverage information to data frame
final_bed$illumina_coverage_filtered <- ill_cov_filt$V4
final_bed$nanopore_coverage <- nano_cov$V4
final_bed$nanopore_coverage_filtered <- nano_cov_filt$V4

# add gc info columns
final_bed$gc_content <- gc_info$gc_content
final_bed$gc_skew <- gc_info$gc_skew
final_bed$gc_culm <- gc_info$gc_culm

# calculate maximum nanopore coverage to display.
maximum_nanopore <- mean(final_bed$nanopore_coverage_filtered) * 1.75
maximum_illumina <- mean(final_bed$illumina_coverage) * 1.75

# replace each one that is over limit each one with maximum
final_bed$nanopore_coverage[which(final_bed$nanopore_coverage > maximum_nanopore)] <- maximum_nanopore

# adjust maximum for purpose of plotting.
final_bed$illumina_coverage[which(final_bed$illumina_coverage > maximum_illumina)] <- maximum_illumina
final_bed$illumina_coverage_filtered[which(final_bed$illumina_coverage_filtered > maximum_illumina)] <- maximum_illumina

# clear plotting region if circos plot already active.
circos.clear()

# open PDF device. this will output the file in the data folder - modify as you wish. 
pdf(paste0(genome, "-circos.pdf"), width = 12, height=15)

# rotate so the beginning of the genome is at the top
# make space between start and end for labels
# remove as much space as possible between layers.
circos.par(start.degree=75, gap.after = 30, cell.padding=c(0,0,0,0))

# this is what the cytoband.df input needs to look like. V4 and V5 are required only when you are plotting multiple chromosomes (like human data for example)
#> cytoband.df
#          V1 V2      V3       V4       V5
#1 contig_125  0 3836404 not_real not_real

# initialize using the cytoband dataframe but don't plot the default.
circos.initializeWithIdeogram(cytoband.df, plotType=NULL)

# generate track for genome.
#circos.track(ylim = c(0,1), panel.fun = function(x,y) {
#}, track.height = 0.05, bg.col="#5e6cff")


# plot all coverage tracks
circos.genomicTrackPlotRegion(final_bed, numeric.column=c("illumina_coverage", "illumina_coverage_filtered", "nanopore_coverage", "nanopore_coverage_filtered") , ylim = c(-(maximum_nanopore), maximum_illumina), panel.fun = function(region, value, ...) {

  circos.genomicLines(region, value, numeric.column="illumina_coverage", baseline = 0, col = rgb(0,0,0,0.5), border = NA, area=TRUE, ...)

  circos.genomicLines(region, value, numeric.column="illumina_coverage_filtered", baseline = 0, col = "#548ce5", border = NA, area=TRUE, ...)


  circos.genomicLines(region, -value, numeric.column="nanopore_coverage", baseline = 0, col = "#fdead8", border = NA, area=TRUE, ...)

  circos.genomicLines(region, -value, numeric.column="nanopore_coverage_filtered", baseline = 0, col = "#f5a556", border = NA, area=TRUE, ...)

  }, track.height = 0.2, bg.border=NA)
  
  # plot a line to highligh the low coverage regions
  # in this case, just the regions with gc > 0.6 were extracted by manual inspection of of final_bed
  circos.rect(243000, 100, 270000, 110, col=rgb(1,1,1,0.5), border = rgb(1,1,1,0.5))
  circos.text(257000, 135, labels="R1", facing="outside", col="#FFFFFF")


# add maximum coverage values for nanopore and illumina reads for scale.
circos.text(0, (maximum_illumina/1.5), adj=c(1.2, 0), labels = as.integer(maximum_illumina), cex = 0.7, col = "#FFFFFF")
circos.text(0, 0, labels = "0", cex = 0.7, adj=c(1.2, 0), col = "#FFFFFF")
circos.text(0, -maximum_nanopore, labels = as.integer(maximum_nanopore), adj=c(1.2, 0), cex = 0.7, col = "#FFFFFF" )
 

# plot gc_content track
circos.genomicTrackPlotRegion(final_bed, numeric.column="gc_content" , ylim = c(min(final_bed$gc_content),max(final_bed$gc_content)), panel.fun = function(region, value, ...) {

    circos.genomicLines(region, value, numeric.column="gc_content", baseline = 0, col = "#FFFFFF", border = NA, ...)

    },track.height = 0.05)

# gc skew and culm track
# the gc_skew and gc_culm columns need to converted to a proportion (i.e. between 0.0 to 1.0) to be plotted on the same track.

# convert to proportion for plotting purposes. 
final_bed$gc_skew <- final_bed$gc_skew / max(final_bed$gc_skew)
final_bed$gc_culm <- final_bed$gc_culm / max(abs(final_bed$gc_culm))

# plot GC skew and culmulative skew on the same track.
circos.genomicTrackPlotRegion(final_bed, numeric.column="gc_culm", ylim = c(-1, 1), panel.fun = function(region, value, ...) {

  circos.genomicLines(region, value, numeric.column="gc_culm", baseline = 0, col = "#8f8f8f", border = NA, area=TRUE,...)

  circos.genomicLines(region, value, numeric.column="gc_skew", baseline = 0, col = "#FFFFFF", border = NA,...)

}, bg.border = NA, track.height = 0.05)

# plot positive coding sequence track
circos.genomicTrackPlotRegion(cds_pos, numeric.column="cds_pos", ylim = c(0, 1), panel.fun = function(region, value, ...) {

  # in every region, print a vertical line at the start region.
  for (k in seq_len(nrow(region))){
    # plot vertical lines for each START of the ORF from bottom to top.
      circos.lines(rep(region[k, 1], 2), c(0, 1), lwd = 2, straight = TRUE, col = rgb(1,1,1,0.7))
  }

}, bg.border = NA, track.height = 0.05)

# plot negative coding sequence track
circos.genomicTrackPlotRegion(cds_neg, numeric.column="cds_neg", ylim = c(0, 1), panel.fun = function(region, value, ...) {

  # in every region, print a vertical line at the start region.
  for (k in seq_len(nrow(region))){
    # plot vertical lines for each START of the orf from bottom to top.
      circos.lines(rep(region[k, 1], 2), c(0, 1), lwd = 2, straight = TRUE, col = rgb(1,1,1,0.7))
  }

}, bg.border = NA, track.height = 0.05)

# plot tRNA and rRNA track
circos.genomicTrackPlotRegion(list(trna, rrna), ylim = c(0, 1), panel.fun = function(region, value, ...) {

  # this will iterate through the list of bed dataframes (trna and rrna)
  i = getI(...)

  # plot tRNAs
  if (i == 1){

    for (k in seq_len(nrow(region))){
      # plot vertical lines for each START of the orf from bottom to top.
        circos.lines(rep(region[k, 1], 2), c(0, 1), lwd = 2, straight = TRUE, col = "#FFFFFF")
    }

  } else {
    # plot rRNAs as red
    for (k in seq_len(nrow(region))){
      # plot vertical lines for each START of the orf from bottom to top.
        circos.lines(rep(region[k, 1], 2), c(0, 1), lwd = 2, straight = TRUE, col = "#dd9521")
    }
  }
}, bg.border = NA, track.height = 0.05)

# clear the plotting area
circos.clear()

# plot the labels in the middle
text(0, 0.88, "Illumina coverage", cex = 1.2, col = "#FFFFFF")
text(0, 0.82, "Nanopore coverage", cex = 1.2, col = "#FFFFFF")
text(0, 0.75, "GC content", cex = 1.3, col = "#FFFFFF")
text(0, 0.68, "GC skew", cex = 1.3, col = "#FFFFFF")
text(0, 0.6, "CDS (+)", cex = 1.3, col = "#FFFFFF")
text(0, 0.52, "CDS (-)", cex = 1.3, col = "#FFFFFF")
text(0, 0.43, "tRNA (White)\n rRNA (Orange)", cex = 1.3, col = "#FFFFFF")
text(0, 0, "UBA1547", cex = 3.5, col = "#FFFFFF")
text(0, -0.1, paste0("Genome size: ", cytoband.df$V3), cex = 1.3, col = "#FFFFFF")

dev.off()
```

```
# Plotting weird region for the CPR genome. 

# munging

### gc content and coverage 
# cd /Volumes/seagate/abahcheli-seagate/mag-validation-seagate/full-attempt/output/circos
d <- read.table("contig_690-gc-info.txt", header=TRUE)
ill_cov <- read.table("contig_690-illumina-hard.regions.bed")
nan_cov <- read.table("contig_690-nanopore-filtered.regions.bed")

# get relatively large window
high_gc_range <- (min(which(d$gc_content > 0.62))-30):(max(which(d$gc_content > 0.62))+30)

# subset all variables so the x axis remains consistent.
d.sub <- d[high_gc_range,]
ill.sub <- ill_cov[high_gc_range,]
nan.sub <- nan_cov[high_gc_range,]

### overlapping reads 

# need to map subsetted reads to final assembly for PAF output
# cd /Volumes/seagate/abahcheli-seagate/mag-validation-seagate/full-attempt/contig_690
# MAP='/Volumes/data/bin/minimap2/minimap2'
# $MAP -x map-ont -t 10 contig_690-final-assembly-oriented.fasta nanopore-filtered-to-final.fastq > pseudoisolate-nanopore-to-final-oriented.paf

# this is the output from minimap 
paf <- read.table("final-oriented-contig_690.paf", stringsAsFactors=FALSE)

# need to find a range of reads. for initial filtering the start OR end position needs to within 250000 and 285000

# starting position or ending position in the region
paf.sub <- paf[which( (paf$V8 > 230000 & paf$V8 < 280000) | (paf$V9 > 230000 & paf$V9 < 280000)),]

# filter the output so that the query coverage is > 90%
paf.sub.filt <- paf.sub[which( ( (paf.sub$V4 - paf.sub$V3) / paf.sub$V2) > 0.9),]

# filter so the minimum read length is > 1000
paf.sub.filt.2 <- paf.sub.filt[which(paf.sub.filt$V2 > 1000 ),]

# further filter so that all remaining reads pass over a junction at 250000 or 284000. 

# range the start to length, check to see if 254000 or 281000 is in that range. 

# initiate final dataframe. 1st row will be replaced, others will be added on
paf.final <- paf.sub.filt.2[1,]

# initialize counter
counter <- 1

for (i in 1:dim(paf.sub.filt.2)[1]) {
    
    if (243000 %in% paf.sub.filt.2$V8[i]:paf.sub.filt.2$V9[i] | (270000 %in% paf.sub.filt.2$V8[i]:paf.sub.filt.2$V9[i]) ) {
        paf.final[counter,] <- paf.sub.filt.2[i,]
        # add to counter. this is needed to add a row at the appropriate spot in the final dataframe
        counter <- counter + 1
    }

}

# take only reads that > 15 kb
paf.final.sub.unfiltered <- paf.final[which(paf.final$V2 > 15000),]

# get rid of a few that don't really show anything
paf.final.sub <- paf.final.sub.unfiltered[-c(3, 5, 9),]

################################################################################

# overlapping reads 

# have three plots 
# middle: gc content
# bottom: illumina + nanopore coverage
# top: overlapping reads 
# it would be cool to 
# mai: bottom left top right
pdf("contig_690-coverage.pdf", width = 7, height = 10)
par(mfrow=c(3,1), mai = c(0.1, 0.82, 0.1, 0.42))

plot(y = d.sub$gc_content, x = ill.sub$V2, ylim = c(0, 26), ylab = "Overlapping Nanopore \n reads", xlab = "", type = "n", axes=FALSE, xlim = c(ill.sub$V2[5], ill.sub$V2[(length(ill.sub$V2) - 5)]))

# x0, y0, x1, y1

for (i in 1:dim(paf.final.sub)[1]) {
    
    # if positive strand
    
    if (i == 12 | i == 20) { 
    
        # these are all on the negative strand
        arrows(x0=paf.final.sub$V9[i], y0=i, x1=paf.final.sub$V8[i], y1=i, lwd = 2, angle = 20, length = 0.1, col = rgb(0,0,0,1))
        
    } else if (i== 24) { 
    
        # these are all on the positive strand
        arrows(x0=paf.final.sub$V8[i], y0=i, x1=paf.final.sub$V9[i], y1=i, lwd = 2, angle = 20, length = 0.1, col = rgb(0,0,0,1))
        
    } else if (paf.final$V5[i] == "+") {
        # increment arrows by 1 every iteration
        arrows(x0=paf.final.sub$V8[i], y0=i, x1=paf.final.sub$V9[i], y1=i, lwd = 2, angle = 20, length = 0.1, col = rgb(245, 185, 96, 255, max = 255))
    } else { 
        # negative strand, plot backwards
        arrows(x0=paf.final.sub$V9[i], y0=i, x1=paf.final.sub$V8[i], y1=i, lwd = 2, angle = 20, length = 0.1, col = rgb(245, 140, 76, 255, max = 255))
    }
    
}

axis(2, c(0, 25)) 

abline(v= 243000, lty = 2, col = rgb(0,0,0,0.7))
abline(v= 270000, lty = 2, col = rgb(0,0,0,0.7))
    
################################################################################

# gc content

# plot the gc content
plot(y = d.sub$gc_content, x = ill.sub$V2, type = "l", axes=FALSE, ylab = "GC content", xlab = "", ylim=c(0.4, 0.7), xlim = c(ill.sub$V2[5], ill.sub$V2[(length(ill.sub$V2) - 5)]))
abline(v= 243000, lty = 2, col = rgb(0,0,0,0.7))
abline(v= 270000, lty = 2, col = rgb(0,0,0,0.7))
axis(2, c(0.4, 0.55, 0.7))

################################################################################

# coverage

# change the mai options for par to see the axis. 
par(mai = c(0.6, 0.82, 0.1, 0.42))

# change the first and last point to zero so the polygon shades to the x-axis
poly.range <- (min(high_gc_range) - 1) : (max(high_gc_range) + 1)

ill.poly <- ill_cov[poly.range,]
ill.poly$V4[c(1, length(ill.poly$V4))] <- 0

nan.poly <- nan_cov[poly.range,]
nan.poly$V4[c(1, length(nan.poly$V4))] <- 0

# cut off the graph early on x-axis for visual purposes. this hides the fact that polygon acts weirdly. 
# illumina coverage
plot(x = ill.sub$V2, y = ill.sub$V4, type = "l", ylab = "Coverage", xlab = "Chromosome position", ylim = c(0, max(ill.sub$V4)), xlim = c(ill.sub$V2[5], ill.sub$V2[(length(ill.sub$V2) - 5)]), axes = FALSE)

# fill in the illumina colour first
polygon(ill.poly$V2, ill.poly$V4, col = rgb(156, 199, 255, 255, max = 255), ylim = c(0, max(ill.sub$V4)), border = "blue")

# nanopore coverage
lines(x = nan.sub$V2, y = nan.sub$V4, type = "l", ylab = "", xlab = "", ylim = c(0, max(ill.sub$V4)), xlim = c(ill.sub$V2[3], ill.sub$V2[(length(ill.sub$V2) - 2)]))

# colour nanopore coverage

# low_nan_cov = "#fdead8"
 #high_nan_cov = "#f5a556"
 
 

polygon(nan.poly$V2, nan.poly$V4,col = "#f5a556" , ylim = c(0, max(ill.sub$V4)), border = "#dc740d" )

axis(1, at = c(214000, 243000, 270000, 297000), labels = c("214 kb", "243 kb", "270 kb", "297 kb"), pos = 0)
axis(2, c(0, 50, 100))

abline(v= 243000, lty = 2, col = rgb(0,0,0,0.7))
abline(v= 270000, lty = 2, col = rgb(0,0,0,0.7))
dev.off()
```

Plot the aquimonas genome: 

````
library(circlize)

# relative path and genome is loaded into this variable 
genome <- "contig_564"

# read in the input files
gc_info <- read.table(paste0(genome, "-gc-info.txt"), header=TRUE)
ill_cov <- read.table(paste0(genome, "-illumina-soft.regions.bed"))
ill_cov_filt <- read.table(paste0(genome, "-illumina-hard.regions.bed"))
nano_cov <- read.table(paste0(genome, "-nanopore-unfiltered.regions.bed"))
nano_cov_filt <- read.table(paste0(genome, "-nanopore-filtered.regions.bed"))

# read in coding sequence bed files
cds_pos <- read.table(paste0(genome, "-cds-positive.bed"), header=TRUE)
cds_neg <- read.table(paste0(genome, "-cds-negative.bed"), header=TRUE)
trna <- read.table(paste0(genome, "-cds-trna.bed"), header=TRUE)
rrna <- read.table(paste0(genome, "-cds-rrna.bed"), header=TRUE)
cytoband.df <- read.table(paste0(genome, "-cytoband.txt"), colClasses=c("character", "numeric", "numeric", "character", "character"))

# generate master bed dataframe for coverage plotting
final_bed <- ill_cov
colnames(final_bed) <- c("chr", "start", "end", "illumina_coverage")

# add coverage information to data frame
final_bed$illumina_coverage_filtered <- ill_cov_filt$V4
final_bed$nanopore_coverage <- nano_cov$V4
final_bed$nanopore_coverage_filtered <- nano_cov_filt$V4

# add gc info columns
final_bed$gc_content <- gc_info$gc_content
final_bed$gc_skew <- gc_info$gc_skew
final_bed$gc_culm <- gc_info$gc_culm

# calculate maximum nanopore coverage to display.
maximum_nanopore <- mean(final_bed$nanopore_coverage_filtered) * 1.75
maximum_illumina <- mean(final_bed$illumina_coverage) * 1.75

# replace each one that is over limit each one with maximum
final_bed$nanopore_coverage[which(final_bed$nanopore_coverage > maximum_nanopore)] <- maximum_nanopore

# adjust maximum for purpose of plotting.
final_bed$illumina_coverage[which(final_bed$illumina_coverage > maximum_illumina)] <- maximum_illumina
final_bed$illumina_coverage_filtered[which(final_bed$illumina_coverage_filtered > maximum_illumina)] <- maximum_illumina

# clear plotting region if circos plot already active.
circos.clear()

# open PDF device. this will output the file in the data folder - modify as you wish. 
pdf(paste0(genome, "-circos.pdf"), width = 12, height=15)

# rotate so the beginning of the genome is at the top
# make space between start and end for labels
# remove as much space as possible between layers.
circos.par(start.degree=75, gap.after = 30, cell.padding=c(0,0,0,0))

# this is what the cytoband.df input needs to look like. V4 and V5 are required only when you are plotting multiple chromosomes (like human data for example)
#> cytoband.df
#          V1 V2      V3       V4       V5
#1 contig_125  0 3836404 not_real not_real

# initialize using the cytoband dataframe but don't plot the default.
circos.initializeWithIdeogram(cytoband.df, plotType=NULL)

# generate track for genome.
#circos.track(ylim = c(0,1), panel.fun = function(x,y) {
#}, track.height = 0.05, bg.col="#5e6cff")

# plot all coverage tracks
circos.genomicTrackPlotRegion(final_bed, numeric.column=c("illumina_coverage", "illumina_coverage_filtered", "nanopore_coverage", "nanopore_coverage_filtered") , ylim = c(-(maximum_nanopore), maximum_illumina), panel.fun = function(region, value, ...) {

  circos.genomicLines(region, value, numeric.column="illumina_coverage", baseline = 0, col = rgb(0,0,0,0.5), border = NA, area=TRUE, ...)

  circos.genomicLines(region, value, numeric.column="illumina_coverage_filtered", baseline = 0, col = "#548ce5", border = NA, area=TRUE, ...)
  

  circos.genomicLines(region, -value, numeric.column="nanopore_coverage", baseline = 0, col = "#fdead8", border = NA, area=TRUE, ...)

  circos.genomicLines(region, -value, numeric.column="nanopore_coverage_filtered", baseline = 0, col = "#f5a556", border = NA, area=TRUE, ...)

  }, track.height = 0.2, bg.border=NA)

# add maximum coverage values for nanopore and illumina reads for scale.
circos.text(0, (maximum_illumina/1.5), adj=c(1.2, 0), labels = as.integer(maximum_illumina), cex = 0.7, col = "#FFFFFF")
circos.text(0, 0, labels = "0", cex = 0.7, adj=c(1.2, 0), col = "#FFFFFF")
circos.text(0, -maximum_nanopore, labels = as.integer(maximum_nanopore), adj=c(1.2, 0), cex = 0.7, col = "#FFFFFF")
 

# plot gc_content track
circos.genomicTrackPlotRegion(final_bed, numeric.column="gc_content" , ylim = c(min(final_bed$gc_content),max(final_bed$gc_content)), panel.fun = function(region, value, ...) {

    circos.genomicLines(region, value, numeric.column="gc_content", baseline = 0, col = "#FFFFFF", border = NA, ...)

    }, track.height = 0.05)

# gc skew and culm track
# the gc_skew and gc_culm columns need to converted to a proportion (i.e. between 0.0 to 1.0) to be plotted on the same track.

# convert to proportion for plotting purposes. 
final_bed$gc_skew <- final_bed$gc_skew / max(final_bed$gc_skew)
final_bed$gc_culm <- final_bed$gc_culm / max(abs(final_bed$gc_culm))

# plot GC skew and culmulative skew on the same track.
circos.genomicTrackPlotRegion(final_bed, numeric.column="gc_culm", ylim = c(-1, 1), panel.fun = function(region, value, ...) {

  circos.genomicLines(region, value, numeric.column="gc_culm", baseline = 0, col = "#8f8f8f", border = NA, area=TRUE,...)

  circos.genomicLines(region, value, numeric.column="gc_skew", baseline = 0, col = "#FFFFFF", border = NA,...)

}, bg.border = NA, track.height = 0.05)

# plot positive coding sequence track
circos.genomicTrackPlotRegion(cds_pos, numeric.column="cds_pos", ylim = c(0, 1), panel.fun = function(region, value, ...) {

  # in every region, print a vertical line at the start region.
  for (k in seq_len(nrow(region))){
    # plot vertical lines for each START of the ORF from bottom to top.
      circos.lines(rep(region[k, 1], 2), c(0, 1), lwd = 0.5, straight = TRUE, col = "#FFFFFF")
  }

}, bg.border = NA, track.height = 0.05)

# plot negative coding sequence track
circos.genomicTrackPlotRegion(cds_neg, numeric.column="cds_neg", ylim = c(0, 1), panel.fun = function(region, value, ...) {

  # in every region, print a vertical line at the start region.
  for (k in seq_len(nrow(region))){
    # plot vertical lines for each START of the orf from bottom to top.
      circos.lines(rep(region[k, 1], 2), c(0, 1), lwd = 0.5, straight = TRUE, col = "#FFFFFF")
  }

}, bg.border = NA, track.height = 0.05)

# plot tRNA and rRNA track
circos.genomicTrackPlotRegion(list(trna, rrna), ylim = c(0, 1), panel.fun = function(region, value, ...) {

  # this will iterate through the list of bed dataframes (trna and rrna)
  i = getI(...)

  # plot tRNAs
  if (i == 1){

    for (k in seq_len(nrow(region))){
      # plot vertical lines for each START of the orf from bottom to top.
        circos.lines(rep(region[k, 1], 2), c(0, 1), lwd = 2, straight = TRUE, col = "#FFFFFF")
    }

  } else {
    # plot rRNAs as red
    for (k in seq_len(nrow(region))){
      # plot vertical lines for each START of the orf from bottom to top.
        circos.lines(rep(region[k, 1], 2), c(0, 1), lwd = 2, straight = TRUE, col = "#dd9521")
    }
  }
}, bg.border = NA, track.height = 0.05)

# clear the plotting area
circos.clear()

# plot the labels in the middle
text(0, 0.88, "Illumina coverage", cex = 1.2, col = "#FFFFFF")
text(0, 0.82, "Nanopore coverage", cex = 1.2, col = "#FFFFFF")
text(0, 0.75, "GC content", cex = 1.3, col = "#FFFFFF")
text(0, 0.68, "GC skew", cex = 1.3, col = "#FFFFFF")
text(0, 0.6, "CDS (+)", cex = 1.3, col = "#FFFFFF")
text(0, 0.52, "CDS (-)", cex = 1.3, col = "#FFFFFF")
text(0, 0.43, "tRNA (White)\n rRNA (Orange)", cex = 1.3, col = "#FFFFFF")
text(0, 0, "Aquimonas", cex = 3.5, col = "#FFFFFF")
text(0, -0.1, paste0("Genome size: ", cytoband.df$V3), cex = 1.3, col = "#FFFFFF")

dev.off()
```
